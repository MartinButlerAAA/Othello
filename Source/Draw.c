// Functions to draw using OSScreen for graphics.
// The header files used with these functions were created with the ProcessBmp tool (see https://github.com/MartinButlerAAA/ProcessBmp).
#include <coreinit/screen.h>	// For OSScreen.

#include "Draw.h"				// Header for graphics drawing.

// Note that the math.h standard library does not seem to work on the main processor when porting code to the Wii U. code lines that can be determined during compilation
// (e.g. cos(2.0f);) compile and work, but maths functions on variables fail to link. As I need some maths functions I have had to do my own versions.
// Lookup table of angle in degrees to sine and cosine values from 0.0 to 360.0 degrees at 0.5 degree intervals for a simple replacement of sin and cos functions.
static float lookup1[721][3] = {
	{   0.0,  0.000,  1.000 },  {   0.5,  0.009,  1.000 },  {   1.0,  0.017,  1.000 },  {   1.5,  0.026,  1.000 },  {   2.0,  0.035,  0.999 },  {   2.5,  0.044,  0.999 },  {   3.0,  0.052,  0.999 },  {   3.5,  0.061,  0.998 },  {   4.0,  0.070,  0.998 },  {   4.5,  0.078,  0.997 },
	{   5.0,  0.087,  0.996 },  {   5.5,  0.096,  0.995 },  {   6.0,  0.105,  0.995 },  {   6.5,  0.113,  0.994 },  {   7.0,  0.122,  0.993 },  {   7.5,  0.131,  0.991 },  {   8.0,  0.139,  0.990 },  {   8.5,  0.148,  0.989 },  {   9.0,  0.156,  0.988 },  {   9.5,  0.165,  0.986 },
	{  10.0,  0.174,  0.985 },  {  10.5,  0.182,  0.983 },  {  11.0,  0.191,  0.982 },  {  11.5,  0.199,  0.980 },  {  12.0,  0.208,  0.978 },  {  12.5,  0.216,  0.976 },  {  13.0,  0.225,  0.974 },  {  13.5,  0.233,  0.972 },  {  14.0,  0.242,  0.970 },  {  14.5,  0.250,  0.968 },
	{  15.0,  0.259,  0.966 },  {  15.5,  0.267,  0.964 },  {  16.0,  0.276,  0.961 },  {  16.5,  0.284,  0.959 },  {  17.0,  0.292,  0.956 },  {  17.5,  0.301,  0.954 },  {  18.0,  0.309,  0.951 },  {  18.5,  0.317,  0.948 },  {  19.0,  0.326,  0.946 },  {  19.5,  0.334,  0.943 },
	{  20.0,  0.342,  0.940 },  {  20.5,  0.350,  0.937 },  {  21.0,  0.358,  0.934 },  {  21.5,  0.367,  0.930 },  {  22.0,  0.375,  0.927 },  {  22.5,  0.383,  0.924 },  {  23.0,  0.391,  0.921 },  {  23.5,  0.399,  0.917 },  {  24.0,  0.407,  0.914 },  {  24.5,  0.415,  0.910 },
	{  25.0,  0.423,  0.906 },  {  25.5,  0.431,  0.903 },  {  26.0,  0.438,  0.899 },  {  26.5,  0.446,  0.895 },  {  27.0,  0.454,  0.891 },  {  27.5,  0.462,  0.887 },  {  28.0,  0.469,  0.883 },  {  28.5,  0.477,  0.879 },  {  29.0,  0.485,  0.875 },  {  29.5,  0.492,  0.870 },
	{  30.0,  0.500,  0.866 },  {  30.5,  0.508,  0.862 },  {  31.0,  0.515,  0.857 },  {  31.5,  0.522,  0.853 },  {  32.0,  0.530,  0.848 },  {  32.5,  0.537,  0.843 },  {  33.0,  0.545,  0.839 },  {  33.5,  0.552,  0.834 },  {  34.0,  0.559,  0.829 },  {  34.5,  0.566,  0.824 },
	{  35.0,  0.574,  0.819 },  {  35.5,  0.581,  0.814 },  {  36.0,  0.588,  0.809 },  {  36.5,  0.595,  0.804 },  {  37.0,  0.602,  0.799 },  {  37.5,  0.609,  0.793 },  {  38.0,  0.616,  0.788 },  {  38.5,  0.623,  0.783 },  {  39.0,  0.629,  0.777 },  {  39.5,  0.636,  0.772 },
	{  40.0,  0.643,  0.766 },  {  40.5,  0.649,  0.760 },  {  41.0,  0.656,  0.755 },  {  41.5,  0.663,  0.749 },  {  42.0,  0.669,  0.743 },  {  42.5,  0.676,  0.737 },  {  43.0,  0.682,  0.731 },  {  43.5,  0.688,  0.725 },  {  44.0,  0.695,  0.719 },  {  44.5,  0.701,  0.713 },
	{  45.0,  0.707,  0.707 },  {  45.5,  0.713,  0.701 },  {  46.0,  0.719,  0.695 },  {  46.5,  0.725,  0.688 },  {  47.0,  0.731,  0.682 },  {  47.5,  0.737,  0.676 },  {  48.0,  0.743,  0.669 },  {  48.5,  0.749,  0.663 },  {  49.0,  0.755,  0.656 },  {  49.5,  0.760,  0.649 },
	{  50.0,  0.766,  0.643 },  {  50.5,  0.772,  0.636 },  {  51.0,  0.777,  0.629 },  {  51.5,  0.783,  0.623 },  {  52.0,  0.788,  0.616 },  {  52.5,  0.793,  0.609 },  {  53.0,  0.799,  0.602 },  {  53.5,  0.804,  0.595 },  {  54.0,  0.809,  0.588 },  {  54.5,  0.814,  0.581 },
	{  55.0,  0.819,  0.574 },  {  55.5,  0.824,  0.566 },  {  56.0,  0.829,  0.559 },  {  56.5,  0.834,  0.552 },  {  57.0,  0.839,  0.545 },  {  57.5,  0.843,  0.537 },  {  58.0,  0.848,  0.530 },  {  58.5,  0.853,  0.522 },  {  59.0,  0.857,  0.515 },  {  59.5,  0.862,  0.508 },
	{  60.0,  0.866,  0.500 },  {  60.5,  0.870,  0.492 },  {  61.0,  0.875,  0.485 },  {  61.5,  0.879,  0.477 },  {  62.0,  0.883,  0.469 },  {  62.5,  0.887,  0.462 },  {  63.0,  0.891,  0.454 },  {  63.5,  0.895,  0.446 },  {  64.0,  0.899,  0.438 },  {  64.5,  0.903,  0.431 },
	{  65.0,  0.906,  0.423 },  {  65.5,  0.910,  0.415 },  {  66.0,  0.914,  0.407 },  {  66.5,  0.917,  0.399 },  {  67.0,  0.921,  0.391 },  {  67.5,  0.924,  0.383 },  {  68.0,  0.927,  0.375 },  {  68.5,  0.930,  0.367 },  {  69.0,  0.934,  0.358 },  {  69.5,  0.937,  0.350 },
	{  70.0,  0.940,  0.342 },  {  70.5,  0.943,  0.334 },  {  71.0,  0.946,  0.326 },  {  71.5,  0.948,  0.317 },  {  72.0,  0.951,  0.309 },  {  72.5,  0.954,  0.301 },  {  73.0,  0.956,  0.292 },  {  73.5,  0.959,  0.284 },  {  74.0,  0.961,  0.276 },  {  74.5,  0.964,  0.267 },
	{  75.0,  0.966,  0.259 },  {  75.5,  0.968,  0.250 },  {  76.0,  0.970,  0.242 },  {  76.5,  0.972,  0.233 },  {  77.0,  0.974,  0.225 },  {  77.5,  0.976,  0.216 },  {  78.0,  0.978,  0.208 },  {  78.5,  0.980,  0.199 },  {  79.0,  0.982,  0.191 },  {  79.5,  0.983,  0.182 },
	{  80.0,  0.985,  0.174 },  {  80.5,  0.986,  0.165 },  {  81.0,  0.988,  0.156 },  {  81.5,  0.989,  0.148 },  {  82.0,  0.990,  0.139 },  {  82.5,  0.991,  0.131 },  {  83.0,  0.993,  0.122 },  {  83.5,  0.994,  0.113 },  {  84.0,  0.995,  0.105 },  {  84.5,  0.995,  0.096 },
	{  85.0,  0.996,  0.087 },  {  85.5,  0.997,  0.078 },  {  86.0,  0.998,  0.070 },  {  86.5,  0.998,  0.061 },  {  87.0,  0.999,  0.052 },  {  87.5,  0.999,  0.044 },  {  88.0,  0.999,  0.035 },  {  88.5,  1.000,  0.026 },  {  89.0,  1.000,  0.017 },  {  89.5,  1.000,  0.009 },
	{  90.0,  1.000,  0.000 },  {  90.5,  1.000, -0.009 },  {  91.0,  1.000, -0.017 },  {  91.5,  1.000, -0.026 },  {  92.0,  0.999, -0.035 },  {  92.5,  0.999, -0.044 },  {  93.0,  0.999, -0.052 },  {  93.5,  0.998, -0.061 },  {  94.0,  0.998, -0.070 },  {  94.5,  0.997, -0.078 },
	{  95.0,  0.996, -0.087 },  {  95.5,  0.995, -0.096 },  {  96.0,  0.995, -0.105 },  {  96.5,  0.994, -0.113 },  {  97.0,  0.993, -0.122 },  {  97.5,  0.991, -0.131 },  {  98.0,  0.990, -0.139 },  {  98.5,  0.989, -0.148 },  {  99.0,  0.988, -0.156 },  {  99.5,  0.986, -0.165 },
	{ 100.0,  0.985, -0.174 },  { 100.5,  0.983, -0.182 },  { 101.0,  0.982, -0.191 },  { 101.5,  0.980, -0.199 },  { 102.0,  0.978, -0.208 },  { 102.5,  0.976, -0.216 },  { 103.0,  0.974, -0.225 },  { 103.5,  0.972, -0.233 },  { 104.0,  0.970, -0.242 },  { 104.5,  0.968, -0.250 },
	{ 105.0,  0.966, -0.259 },  { 105.5,  0.964, -0.267 },  { 106.0,  0.961, -0.276 },  { 106.5,  0.959, -0.284 },  { 107.0,  0.956, -0.292 },  { 107.5,  0.954, -0.301 },  { 108.0,  0.951, -0.309 },  { 108.5,  0.948, -0.317 },  { 109.0,  0.946, -0.326 },  { 109.5,  0.943, -0.334 },
	{ 110.0,  0.940, -0.342 },  { 110.5,  0.937, -0.350 },  { 111.0,  0.934, -0.358 },  { 111.5,  0.930, -0.367 },  { 112.0,  0.927, -0.375 },  { 112.5,  0.924, -0.383 },  { 113.0,  0.921, -0.391 },  { 113.5,  0.917, -0.399 },  { 114.0,  0.914, -0.407 },  { 114.5,  0.910, -0.415 },
	{ 115.0,  0.906, -0.423 },  { 115.5,  0.903, -0.431 },  { 116.0,  0.899, -0.438 },  { 116.5,  0.895, -0.446 },  { 117.0,  0.891, -0.454 },  { 117.5,  0.887, -0.462 },  { 118.0,  0.883, -0.469 },  { 118.5,  0.879, -0.477 },  { 119.0,  0.875, -0.485 },  { 119.5,  0.870, -0.492 },
	{ 120.0,  0.866, -0.500 },  { 120.5,  0.862, -0.508 },  { 121.0,  0.857, -0.515 },  { 121.5,  0.853, -0.522 },  { 122.0,  0.848, -0.530 },  { 122.5,  0.843, -0.537 },  { 123.0,  0.839, -0.545 },  { 123.5,  0.834, -0.552 },  { 124.0,  0.829, -0.559 },  { 124.5,  0.824, -0.566 },
	{ 125.0,  0.819, -0.574 },  { 125.5,  0.814, -0.581 },  { 126.0,  0.809, -0.588 },  { 126.5,  0.804, -0.595 },  { 127.0,  0.799, -0.602 },  { 127.5,  0.793, -0.609 },  { 128.0,  0.788, -0.616 },  { 128.5,  0.783, -0.623 },  { 129.0,  0.777, -0.629 },  { 129.5,  0.772, -0.636 },
	{ 130.0,  0.766, -0.643 },  { 130.5,  0.760, -0.649 },  { 131.0,  0.755, -0.656 },  { 131.5,  0.749, -0.663 },  { 132.0,  0.743, -0.669 },  { 132.5,  0.737, -0.676 },  { 133.0,  0.731, -0.682 },  { 133.5,  0.725, -0.688 },  { 134.0,  0.719, -0.695 },  { 134.5,  0.713, -0.701 },
	{ 135.0,  0.707, -0.707 },  { 135.5,  0.701, -0.713 },  { 136.0,  0.695, -0.719 },  { 136.5,  0.688, -0.725 },  { 137.0,  0.682, -0.731 },  { 137.5,  0.676, -0.737 },  { 138.0,  0.669, -0.743 },  { 138.5,  0.663, -0.749 },  { 139.0,  0.656, -0.755 },  { 139.5,  0.649, -0.760 },
	{ 140.0,  0.643, -0.766 },  { 140.5,  0.636, -0.772 },  { 141.0,  0.629, -0.777 },  { 141.5,  0.623, -0.783 },  { 142.0,  0.616, -0.788 },  { 142.5,  0.609, -0.793 },  { 143.0,  0.602, -0.799 },  { 143.5,  0.595, -0.804 },  { 144.0,  0.588, -0.809 },  { 144.5,  0.581, -0.814 },
	{ 145.0,  0.574, -0.819 },  { 145.5,  0.566, -0.824 },  { 146.0,  0.559, -0.829 },  { 146.5,  0.552, -0.834 },  { 147.0,  0.545, -0.839 },  { 147.5,  0.537, -0.843 },  { 148.0,  0.530, -0.848 },  { 148.5,  0.522, -0.853 },  { 149.0,  0.515, -0.857 },  { 149.5,  0.508, -0.862 },
	{ 150.0,  0.500, -0.866 },  { 150.5,  0.492, -0.870 },  { 151.0,  0.485, -0.875 },  { 151.5,  0.477, -0.879 },  { 152.0,  0.469, -0.883 },  { 152.5,  0.462, -0.887 },  { 153.0,  0.454, -0.891 },  { 153.5,  0.446, -0.895 },  { 154.0,  0.438, -0.899 },  { 154.5,  0.431, -0.903 },
	{ 155.0,  0.423, -0.906 },  { 155.5,  0.415, -0.910 },  { 156.0,  0.407, -0.914 },  { 156.5,  0.399, -0.917 },  { 157.0,  0.391, -0.921 },  { 157.5,  0.383, -0.924 },  { 158.0,  0.375, -0.927 },  { 158.5,  0.367, -0.930 },  { 159.0,  0.358, -0.934 },  { 159.5,  0.350, -0.937 },
	{ 160.0,  0.342, -0.940 },  { 160.5,  0.334, -0.943 },  { 161.0,  0.326, -0.946 },  { 161.5,  0.317, -0.948 },  { 162.0,  0.309, -0.951 },  { 162.5,  0.301, -0.954 },  { 163.0,  0.292, -0.956 },  { 163.5,  0.284, -0.959 },  { 164.0,  0.276, -0.961 },  { 164.5,  0.267, -0.964 },
	{ 165.0,  0.259, -0.966 },  { 165.5,  0.250, -0.968 },  { 166.0,  0.242, -0.970 },  { 166.5,  0.233, -0.972 },  { 167.0,  0.225, -0.974 },  { 167.5,  0.216, -0.976 },  { 168.0,  0.208, -0.978 },  { 168.5,  0.199, -0.980 },  { 169.0,  0.191, -0.982 },  { 169.5,  0.182, -0.983 },
	{ 170.0,  0.174, -0.985 },  { 170.5,  0.165, -0.986 },  { 171.0,  0.156, -0.988 },  { 171.5,  0.148, -0.989 },  { 172.0,  0.139, -0.990 },  { 172.5,  0.131, -0.991 },  { 173.0,  0.122, -0.993 },  { 173.5,  0.113, -0.994 },  { 174.0,  0.105, -0.995 },  { 174.5,  0.096, -0.995 },
	{ 175.0,  0.087, -0.996 },  { 175.5,  0.078, -0.997 },  { 176.0,  0.070, -0.998 },  { 176.5,  0.061, -0.998 },  { 177.0,  0.052, -0.999 },  { 177.5,  0.044, -0.999 },  { 178.0,  0.035, -0.999 },  { 178.5,  0.026, -1.000 },  { 179.0,  0.017, -1.000 },  { 179.5,  0.009, -1.000 },
	{ 180.0,  0.000, -1.000 },  { 180.5, -0.009, -1.000 },  { 181.0, -0.017, -1.000 },  { 181.5, -0.026, -1.000 },  { 182.0, -0.035, -0.999 },  { 182.5, -0.044, -0.999 },  { 183.0, -0.052, -0.999 },  { 183.5, -0.061, -0.998 },  { 184.0, -0.070, -0.998 },  { 184.5, -0.078, -0.997 },
	{ 185.0, -0.087, -0.996 },  { 185.5, -0.096, -0.995 },  { 186.0, -0.105, -0.995 },  { 186.5, -0.113, -0.994 },  { 187.0, -0.122, -0.993 },  { 187.5, -0.131, -0.991 },  { 188.0, -0.139, -0.990 },  { 188.5, -0.148, -0.989 },  { 189.0, -0.156, -0.988 },  { 189.5, -0.165, -0.986 },
	{ 190.0, -0.174, -0.985 },  { 190.5, -0.182, -0.983 },  { 191.0, -0.191, -0.982 },  { 191.5, -0.199, -0.980 },  { 192.0, -0.208, -0.978 },  { 192.5, -0.216, -0.976 },  { 193.0, -0.225, -0.974 },  { 193.5, -0.233, -0.972 },  { 194.0, -0.242, -0.970 },  { 194.5, -0.250, -0.968 },
	{ 195.0, -0.259, -0.966 },  { 195.5, -0.267, -0.964 },  { 196.0, -0.276, -0.961 },  { 196.5, -0.284, -0.959 },  { 197.0, -0.292, -0.956 },  { 197.5, -0.301, -0.954 },  { 198.0, -0.309, -0.951 },  { 198.5, -0.317, -0.948 },  { 199.0, -0.326, -0.946 },  { 199.5, -0.334, -0.943 },
	{ 200.0, -0.342, -0.940 },  { 200.5, -0.350, -0.937 },  { 201.0, -0.358, -0.934 },  { 201.5, -0.367, -0.930 },  { 202.0, -0.375, -0.927 },  { 202.5, -0.383, -0.924 },  { 203.0, -0.391, -0.921 },  { 203.5, -0.399, -0.917 },  { 204.0, -0.407, -0.914 },  { 204.5, -0.415, -0.910 },
	{ 205.0, -0.423, -0.906 },  { 205.5, -0.431, -0.903 },  { 206.0, -0.438, -0.899 },  { 206.5, -0.446, -0.895 },  { 207.0, -0.454, -0.891 },  { 207.5, -0.462, -0.887 },  { 208.0, -0.469, -0.883 },  { 208.5, -0.477, -0.879 },  { 209.0, -0.485, -0.875 },  { 209.5, -0.492, -0.870 },
	{ 210.0, -0.500, -0.866 },  { 210.5, -0.508, -0.862 },  { 211.0, -0.515, -0.857 },  { 211.5, -0.522, -0.853 },  { 212.0, -0.530, -0.848 },  { 212.5, -0.537, -0.843 },  { 213.0, -0.545, -0.839 },  { 213.5, -0.552, -0.834 },  { 214.0, -0.559, -0.829 },  { 214.5, -0.566, -0.824 },
	{ 215.0, -0.574, -0.819 },  { 215.5, -0.581, -0.814 },  { 216.0, -0.588, -0.809 },  { 216.5, -0.595, -0.804 },  { 217.0, -0.602, -0.799 },  { 217.5, -0.609, -0.793 },  { 218.0, -0.616, -0.788 },  { 218.5, -0.623, -0.783 },  { 219.0, -0.629, -0.777 },  { 219.5, -0.636, -0.772 },
	{ 220.0, -0.643, -0.766 },  { 220.5, -0.649, -0.760 },  { 221.0, -0.656, -0.755 },  { 221.5, -0.663, -0.749 },  { 222.0, -0.669, -0.743 },  { 222.5, -0.676, -0.737 },  { 223.0, -0.682, -0.731 },  { 223.5, -0.688, -0.725 },  { 224.0, -0.695, -0.719 },  { 224.5, -0.701, -0.713 },
	{ 225.0, -0.707, -0.707 },  { 225.5, -0.713, -0.701 },  { 226.0, -0.719, -0.695 },  { 226.5, -0.725, -0.688 },  { 227.0, -0.731, -0.682 },  { 227.5, -0.737, -0.676 },  { 228.0, -0.743, -0.669 },  { 228.5, -0.749, -0.663 },  { 229.0, -0.755, -0.656 },  { 229.5, -0.760, -0.649 },
	{ 230.0, -0.766, -0.643 },  { 230.5, -0.772, -0.636 },  { 231.0, -0.777, -0.629 },  { 231.5, -0.783, -0.623 },  { 232.0, -0.788, -0.616 },  { 232.5, -0.793, -0.609 },  { 233.0, -0.799, -0.602 },  { 233.5, -0.804, -0.595 },  { 234.0, -0.809, -0.588 },  { 234.5, -0.814, -0.581 },
	{ 235.0, -0.819, -0.574 },  { 235.5, -0.824, -0.566 },  { 236.0, -0.829, -0.559 },  { 236.5, -0.834, -0.552 },  { 237.0, -0.839, -0.545 },  { 237.5, -0.843, -0.537 },  { 238.0, -0.848, -0.530 },  { 238.5, -0.853, -0.522 },  { 239.0, -0.857, -0.515 },  { 239.5, -0.862, -0.508 },
	{ 240.0, -0.866, -0.500 },  { 240.5, -0.870, -0.492 },  { 241.0, -0.875, -0.485 },  { 241.5, -0.879, -0.477 },  { 242.0, -0.883, -0.469 },  { 242.5, -0.887, -0.462 },  { 243.0, -0.891, -0.454 },  { 243.5, -0.895, -0.446 },  { 244.0, -0.899, -0.438 },  { 244.5, -0.903, -0.431 },
	{ 245.0, -0.906, -0.423 },  { 245.5, -0.910, -0.415 },  { 246.0, -0.914, -0.407 },  { 246.5, -0.917, -0.399 },  { 247.0, -0.921, -0.391 },  { 247.5, -0.924, -0.383 },  { 248.0, -0.927, -0.375 },  { 248.5, -0.930, -0.367 },  { 249.0, -0.934, -0.358 },  { 249.5, -0.937, -0.350 },
	{ 250.0, -0.940, -0.342 },  { 250.5, -0.943, -0.334 },  { 251.0, -0.946, -0.326 },  { 251.5, -0.948, -0.317 },  { 252.0, -0.951, -0.309 },  { 252.5, -0.954, -0.301 },  { 253.0, -0.956, -0.292 },  { 253.5, -0.959, -0.284 },  { 254.0, -0.961, -0.276 },  { 254.5, -0.964, -0.267 },
	{ 255.0, -0.966, -0.259 },  { 255.5, -0.968, -0.250 },  { 256.0, -0.970, -0.242 },  { 256.5, -0.972, -0.233 },  { 257.0, -0.974, -0.225 },  { 257.5, -0.976, -0.216 },  { 258.0, -0.978, -0.208 },  { 258.5, -0.980, -0.199 },  { 259.0, -0.982, -0.191 },  { 259.5, -0.983, -0.182 },
	{ 260.0, -0.985, -0.174 },  { 260.5, -0.986, -0.165 },  { 261.0, -0.988, -0.156 },  { 261.5, -0.989, -0.148 },  { 262.0, -0.990, -0.139 },  { 262.5, -0.991, -0.131 },  { 263.0, -0.993, -0.122 },  { 263.5, -0.994, -0.113 },  { 264.0, -0.995, -0.105 },  { 264.5, -0.995, -0.096 },
	{ 265.0, -0.996, -0.087 },  { 265.5, -0.997, -0.078 },  { 266.0, -0.998, -0.070 },  { 266.5, -0.998, -0.061 },  { 267.0, -0.999, -0.052 },  { 267.5, -0.999, -0.044 },  { 268.0, -0.999, -0.035 },  { 268.5, -1.000, -0.026 },  { 269.0, -1.000, -0.017 },  { 269.5, -1.000, -0.009 },
	{ 270.0, -1.000,  0.000 },  { 270.5, -1.000,  0.009 },  { 271.0, -1.000,  0.017 },  { 271.5, -1.000,  0.026 },  { 272.0, -0.999,  0.035 },  { 272.5, -0.999,  0.044 },  { 273.0, -0.999,  0.052 },  { 273.5, -0.998,  0.061 },  { 274.0, -0.998,  0.070 },  { 274.5, -0.997,  0.078 },
	{ 275.0, -0.996,  0.087 },  { 275.5, -0.995,  0.096 },  { 276.0, -0.995,  0.105 },  { 276.5, -0.994,  0.113 },  { 277.0, -0.993,  0.122 },  { 277.5, -0.991,  0.131 },  { 278.0, -0.990,  0.139 },  { 278.5, -0.989,  0.148 },  { 279.0, -0.988,  0.156 },  { 279.5, -0.986,  0.165 },
	{ 280.0, -0.985,  0.174 },  { 280.5, -0.983,  0.182 },  { 281.0, -0.982,  0.191 },  { 281.5, -0.980,  0.199 },  { 282.0, -0.978,  0.208 },  { 282.5, -0.976,  0.216 },  { 283.0, -0.974,  0.225 },  { 283.5, -0.972,  0.233 },  { 284.0, -0.970,  0.242 },  { 284.5, -0.968,  0.250 },
	{ 285.0, -0.966,  0.259 },  { 285.5, -0.964,  0.267 },  { 286.0, -0.961,  0.276 },  { 286.5, -0.959,  0.284 },  { 287.0, -0.956,  0.292 },  { 287.5, -0.954,  0.301 },  { 288.0, -0.951,  0.309 },  { 288.5, -0.948,  0.317 },  { 289.0, -0.946,  0.326 },  { 289.5, -0.943,  0.334 },
	{ 290.0, -0.940,  0.342 },  { 290.5, -0.937,  0.350 },  { 291.0, -0.934,  0.358 },  { 291.5, -0.930,  0.367 },  { 292.0, -0.927,  0.375 },  { 292.5, -0.924,  0.383 },  { 293.0, -0.921,  0.391 },  { 293.5, -0.917,  0.399 },  { 294.0, -0.914,  0.407 },  { 294.5, -0.910,  0.415 },
	{ 295.0, -0.906,  0.423 },  { 295.5, -0.903,  0.431 },  { 296.0, -0.899,  0.438 },  { 296.5, -0.895,  0.446 },  { 297.0, -0.891,  0.454 },  { 297.5, -0.887,  0.462 },  { 298.0, -0.883,  0.469 },  { 298.5, -0.879,  0.477 },  { 299.0, -0.875,  0.485 },  { 299.5, -0.870,  0.492 },
	{ 300.0, -0.866,  0.500 },  { 300.5, -0.862,  0.508 },  { 301.0, -0.857,  0.515 },  { 301.5, -0.853,  0.522 },  { 302.0, -0.848,  0.530 },  { 302.5, -0.843,  0.537 },  { 303.0, -0.839,  0.545 },  { 303.5, -0.834,  0.552 },  { 304.0, -0.829,  0.559 },  { 304.5, -0.824,  0.566 },
	{ 305.0, -0.819,  0.574 },  { 305.5, -0.814,  0.581 },  { 306.0, -0.809,  0.588 },  { 306.5, -0.804,  0.595 },  { 307.0, -0.799,  0.602 },  { 307.5, -0.793,  0.609 },  { 308.0, -0.788,  0.616 },  { 308.5, -0.783,  0.623 },  { 309.0, -0.777,  0.629 },  { 309.5, -0.772,  0.636 },
	{ 310.0, -0.766,  0.643 },  { 310.5, -0.760,  0.649 },  { 311.0, -0.755,  0.656 },  { 311.5, -0.749,  0.663 },  { 312.0, -0.743,  0.669 },  { 312.5, -0.737,  0.676 },  { 313.0, -0.731,  0.682 },  { 313.5, -0.725,  0.688 },  { 314.0, -0.719,  0.695 },  { 314.5, -0.713,  0.701 },
	{ 315.0, -0.707,  0.707 },  { 315.5, -0.701,  0.713 },  { 316.0, -0.695,  0.719 },  { 316.5, -0.688,  0.725 },  { 317.0, -0.682,  0.731 },  { 317.5, -0.676,  0.737 },  { 318.0, -0.669,  0.743 },  { 318.5, -0.663,  0.749 },  { 319.0, -0.656,  0.755 },  { 319.5, -0.649,  0.760 },
	{ 320.0, -0.643,  0.766 },  { 320.5, -0.636,  0.772 },  { 321.0, -0.629,  0.777 },  { 321.5, -0.623,  0.783 },  { 322.0, -0.616,  0.788 },  { 322.5, -0.609,  0.793 },  { 323.0, -0.602,  0.799 },  { 323.5, -0.595,  0.804 },  { 324.0, -0.588,  0.809 },  { 324.5, -0.581,  0.814 },
	{ 325.0, -0.574,  0.819 },  { 325.5, -0.566,  0.824 },  { 326.0, -0.559,  0.829 },  { 326.5, -0.552,  0.834 },  { 327.0, -0.545,  0.839 },  { 327.5, -0.537,  0.843 },  { 328.0, -0.530,  0.848 },  { 328.5, -0.522,  0.853 },  { 329.0, -0.515,  0.857 },  { 329.5, -0.508,  0.862 },
	{ 330.0, -0.500,  0.866 },  { 330.5, -0.492,  0.870 },  { 331.0, -0.485,  0.875 },  { 331.5, -0.477,  0.879 },  { 332.0, -0.469,  0.883 },  { 332.5, -0.462,  0.887 },  { 333.0, -0.454,  0.891 },  { 333.5, -0.446,  0.895 },  { 334.0, -0.438,  0.899 },  { 334.5, -0.431,  0.903 },
	{ 335.0, -0.423,  0.906 },  { 335.5, -0.415,  0.910 },  { 336.0, -0.407,  0.914 },  { 336.5, -0.399,  0.917 },  { 337.0, -0.391,  0.921 },  { 337.5, -0.383,  0.924 },  { 338.0, -0.375,  0.927 },  { 338.5, -0.367,  0.930 },  { 339.0, -0.358,  0.934 },  { 339.5, -0.350,  0.937 },
	{ 340.0, -0.342,  0.940 },  { 340.5, -0.334,  0.943 },  { 341.0, -0.326,  0.946 },  { 341.5, -0.317,  0.948 },  { 342.0, -0.309,  0.951 },  { 342.5, -0.301,  0.954 },  { 343.0, -0.292,  0.956 },  { 343.5, -0.284,  0.959 },  { 344.0, -0.276,  0.961 },  { 344.5, -0.267,  0.964 },
	{ 345.0, -0.259,  0.966 },  { 345.5, -0.250,  0.968 },  { 346.0, -0.242,  0.970 },  { 346.5, -0.233,  0.972 },  { 347.0, -0.225,  0.974 },  { 347.5, -0.216,  0.976 },  { 348.0, -0.208,  0.978 },  { 348.5, -0.199,  0.980 },  { 349.0, -0.191,  0.982 },  { 349.5, -0.182,  0.983 },
	{ 350.0, -0.174,  0.985 },  { 350.5, -0.165,  0.986 },  { 351.0, -0.156,  0.988 },  { 351.5, -0.148,  0.989 },  { 352.0, -0.139,  0.990 },  { 352.5, -0.131,  0.991 },  { 353.0, -0.122,  0.993 },  { 353.5, -0.113,  0.994 },  { 354.0, -0.105,  0.995 },  { 354.5, -0.096,  0.995 },
	{ 355.0, -0.087,  0.996 },  { 355.5, -0.078,  0.997 },  { 356.0, -0.070,  0.998 },  { 356.5, -0.061,  0.998 },  { 357.0, -0.052,  0.999 },  { 357.5, -0.044,  0.999 },  { 358.0, -0.035,  0.999 },  { 358.5, -0.026,  1.000 },  { 359.0, -0.017,  1.000 },  { 359.5, -0.009,  1.000 },
	{ 360.0,  0.000,  1.000 } };

// Lookup table of tan from 0.0 to 1.0 in 0.005 intervals (0.0 to 45.0 degrees) to support an Atan2 function replacement.
static float lookup2[201][2] = {
	{ 0.000,  0.000 }, { 0.005,  0.286 }, { 0.010,  0.573 }, { 0.015,  0.859 }, { 0.020,  1.146 }, { 0.025,  1.432 }, { 0.030,  1.718 }, { 0.035,  2.005 }, { 0.040,  2.291 }, { 0.045,  2.577 },
	{ 0.050,  2.862 }, { 0.055,  3.148 }, { 0.060,  3.434 }, { 0.065,  3.719 }, { 0.070,  4.004 }, { 0.075,  4.289 }, { 0.080,  4.574 }, { 0.085,  4.858 }, { 0.090,  5.143 }, { 0.095,  5.427 },
	{ 0.100,  5.711 }, { 0.105,  5.994 }, { 0.110,  6.277 }, { 0.115,  6.560 }, { 0.120,  6.843 }, { 0.125,  7.125 }, { 0.130,  7.407 }, { 0.135,  7.688 }, { 0.140,  7.970 }, { 0.145,  8.250 },
	{ 0.150,  8.531 }, { 0.155,  8.811 }, { 0.160,  9.090 }, { 0.165,  9.369 }, { 0.170,  9.648 }, { 0.175,  9.926 }, { 0.180, 10.204 }, { 0.185, 10.481 }, { 0.190, 10.758 }, { 0.195, 11.034 },
	{ 0.200, 11.310 }, { 0.205, 11.585 }, { 0.210, 11.860 }, { 0.215, 12.134 }, { 0.220, 12.407 }, { 0.225, 12.680 }, { 0.230, 12.953 }, { 0.235, 13.225 }, { 0.240, 13.496 }, { 0.245, 13.766 },
	{ 0.250, 14.036 }, { 0.255, 14.306 }, { 0.260, 14.574 }, { 0.265, 14.842 }, { 0.270, 15.110 }, { 0.275, 15.376 }, { 0.280, 15.642 }, { 0.285, 15.908 }, { 0.290, 16.172 }, { 0.295, 16.436 },
	{ 0.300, 16.699 }, { 0.305, 16.962 }, { 0.310, 17.223 }, { 0.315, 17.484 }, { 0.320, 17.745 }, { 0.325, 18.004 }, { 0.330, 18.263 }, { 0.335, 18.521 }, { 0.340, 18.778 }, { 0.345, 19.034 },
	{ 0.350, 19.290 }, { 0.355, 19.545 }, { 0.360, 19.799 }, { 0.365, 20.052 }, { 0.370, 20.304 }, { 0.375, 20.556 }, { 0.380, 20.807 }, { 0.385, 21.057 }, { 0.390, 21.306 }, { 0.395, 21.554 },
	{ 0.400, 21.801 }, { 0.405, 22.048 }, { 0.410, 22.294 }, { 0.415, 22.538 }, { 0.420, 22.782 }, { 0.425, 23.025 }, { 0.430, 23.268 }, { 0.435, 23.509 }, { 0.440, 23.749 }, { 0.445, 23.989 },
	{ 0.450, 24.228 }, { 0.455, 24.466 }, { 0.460, 24.702 }, { 0.465, 24.938 }, { 0.470, 25.174 }, { 0.475, 25.408 }, { 0.480, 25.641 }, { 0.485, 25.873 }, { 0.490, 26.105 }, { 0.495, 26.335 },
	{ 0.500, 26.565 }, { 0.505, 26.794 }, { 0.510, 27.022 }, { 0.515, 27.248 }, { 0.520, 27.474 }, { 0.525, 27.699 }, { 0.530, 27.924 }, { 0.535, 28.147 }, { 0.540, 28.369 }, { 0.545, 28.590 },
	{ 0.550, 28.811 }, { 0.555, 29.030 }, { 0.560, 29.249 }, { 0.565, 29.466 }, { 0.570, 29.683 }, { 0.575, 29.899 }, { 0.580, 30.114 }, { 0.585, 30.328 }, { 0.590, 30.541 }, { 0.595, 30.753 },
	{ 0.600, 30.964 }, { 0.605, 31.174 }, { 0.610, 31.383 }, { 0.615, 31.592 }, { 0.620, 31.799 }, { 0.625, 32.005 }, { 0.630, 32.211 }, { 0.635, 32.416 }, { 0.640, 32.619 }, { 0.645, 32.822 },
	{ 0.650, 33.024 }, { 0.655, 33.225 }, { 0.660, 33.425 }, { 0.665, 33.624 }, { 0.670, 33.822 }, { 0.675, 34.019 }, { 0.680, 34.216 }, { 0.685, 34.411 }, { 0.690, 34.606 }, { 0.695, 34.799 },
	{ 0.700, 34.992 }, { 0.705, 35.184 }, { 0.710, 35.375 }, { 0.715, 35.565 }, { 0.720, 35.754 }, { 0.725, 35.942 }, { 0.730, 36.129 }, { 0.735, 36.316 }, { 0.740, 36.501 }, { 0.745, 36.686 },
	{ 0.750, 36.870 }, { 0.755, 37.053 }, { 0.760, 37.235 }, { 0.765, 37.416 }, { 0.770, 37.596 }, { 0.775, 37.776 }, { 0.780, 37.954 }, { 0.785, 38.132 }, { 0.790, 38.309 }, { 0.795, 38.485 },
	{ 0.800, 38.660 }, { 0.805, 38.834 }, { 0.810, 39.007 }, { 0.815, 39.180 }, { 0.820, 39.352 }, { 0.825, 39.523 }, { 0.830, 39.693 }, { 0.835, 39.862 }, { 0.840, 40.030 }, { 0.845, 40.198 },
	{ 0.850, 40.365 }, { 0.855, 40.530 }, { 0.860, 40.696 }, { 0.865, 40.860 }, { 0.870, 41.023 }, { 0.875, 41.186 }, { 0.880, 41.348 }, { 0.885, 41.509 }, { 0.890, 41.669 }, { 0.895, 41.829 },
	{ 0.900, 41.987 }, { 0.905, 42.145 }, { 0.910, 42.302 }, { 0.915, 42.459 }, { 0.920, 42.614 }, { 0.925, 42.769 }, { 0.930, 42.923 }, { 0.935, 43.076 }, { 0.940, 43.229 }, { 0.945, 43.380 },
	{ 0.950, 43.531 }, { 0.955, 43.681 }, { 0.960, 43.831 }, { 0.965, 43.980 }, { 0.970, 44.128 }, { 0.975, 44.275 }, { 0.980, 44.421 }, { 0.985, 44.567 }, { 0.990, 44.712 }, { 0.995, 44.856 },
	{ 1.000, 45.000 } };


// Needed a font, so that text could be any colour, size and position on the screen. Found the following after an internet search:

/**
 * 8x8 monochrome bitmap fonts for rendering
 * Author: Daniel Hepper <daniel@hepper.net>
 *
 * License: Public Domain
 *
 * Based on:
 * // Summary: font8x8.h
 * // 8x8 monochrome bitmap fonts for rendering
 * //
 * // Author:
 * //     Marcel Sondaar
 * //     International Business Machines (public domain VGA fonts)
 * //
 * // License:
 * //     Public Domain
 **/

// Contains an 8x8 font map for unicode points U+0020 - U+007F (basic latin)
static char font8x8_basic[96][8] = {
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0020 (space)
{ 0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00},   // U+0021 (!)
{ 0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0022 (")
{ 0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00},   // U+0023 (#)
{ 0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00},   // U+0024 ($)
{ 0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00},   // U+0025 (%)
{ 0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00},   // U+0026 (&)
{ 0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0027 (')
{ 0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00},   // U+0028 (()
{ 0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00},   // U+0029 ())
{ 0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00},   // U+002A (*)
{ 0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00},   // U+002B (+)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+002C (,)
{ 0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00},   // U+002D (-)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+002E (.)
{ 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00},   // U+002F (/)
{ 0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00},   // U+0030 (0)
{ 0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00},   // U+0031 (1)
{ 0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00},   // U+0032 (2)
{ 0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00},   // U+0033 (3)
{ 0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00},   // U+0034 (4)
{ 0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00},   // U+0035 (5)
{ 0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00},   // U+0036 (6)
{ 0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00},   // U+0037 (7)
{ 0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00},   // U+0038 (8)
{ 0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00},   // U+0039 (9)
{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00},   // U+003A (:)
{ 0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x06},   // U+003B (;)
{ 0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00},   // U+003C (<)
{ 0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00},   // U+003D (=)
{ 0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00},   // U+003E (>)
{ 0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00},   // U+003F (?)
{ 0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00},   // U+0040 (@)
{ 0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00},   // U+0041 (A)
{ 0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00},   // U+0042 (B)
{ 0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00},   // U+0043 (C)
{ 0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00},   // U+0044 (D)
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00},   // U+0045 (E)
{ 0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00},   // U+0046 (F)
{ 0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00},   // U+0047 (G)
{ 0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00},   // U+0048 (H)
{ 0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0049 (I)
{ 0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00},   // U+004A (J)
{ 0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00},   // U+004B (K)
{ 0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00},   // U+004C (L)
{ 0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00},   // U+004D (M)
{ 0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00},   // U+004E (N)
{ 0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00},   // U+004F (O)
{ 0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00},   // U+0050 (P)
{ 0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00},   // U+0051 (Q)
{ 0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00},   // U+0052 (R)
{ 0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00},   // U+0053 (S)
{ 0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0054 (T)
{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00},   // U+0055 (U)
{ 0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0056 (V)
{ 0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00},   // U+0057 (W)
{ 0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00},   // U+0058 (X)
{ 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00},   // U+0059 (Y)
{ 0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00},   // U+005A (Z)
{ 0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00},   // U+005B ([)
{ 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00},   // U+005C (\)
{ 0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00},   // U+005D (])
{ 0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00},   // U+005E (^)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF},   // U+005F (_)
{ 0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+0060 (`)
{ 0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00},   // U+0061 (a)
{ 0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00},   // U+0062 (b)
{ 0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00},   // U+0063 (c)
{ 0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00},   // U+0064 (d)
{ 0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00},   // U+0065 (e)
{ 0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00},   // U+0066 (f)
{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0067 (g)
{ 0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00},   // U+0068 (h)
{ 0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+0069 (i)
{ 0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E},   // U+006A (j)
{ 0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00},   // U+006B (k)
{ 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00},   // U+006C (l)
{ 0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00},   // U+006D (m)
{ 0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00},   // U+006E (n)
{ 0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00},   // U+006F (o)
{ 0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F},   // U+0070 (p)
{ 0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78},   // U+0071 (q)
{ 0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00},   // U+0072 (r)
{ 0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00},   // U+0073 (s)
{ 0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00},   // U+0074 (t)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00},   // U+0075 (u)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00},   // U+0076 (v)
{ 0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00},   // U+0077 (w)
{ 0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00},   // U+0078 (x)
{ 0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F},   // U+0079 (y)
{ 0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00},   // U+007A (z)
{ 0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00},   // U+007B ({)
{ 0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00},   // U+007C (|)
{ 0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00},   // U+007D (})
{ 0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00},   // U+007E (~)
{ 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00} };

// The function abs is available from stdlib.h on the PC, but not on the Wii U. 
// A local version of abs is used here, so that the trig functions could be developed and tested on a PC, before use on the Wii U.
static float myAbs(float a)
{
	if (a >= 0)
	{
		return a;
	}
	else
	{
		return -a;
	}
}

// Replacement Atan2 function to support where maths functions are not available.
static float myAtan2(float y, float x)
{
	float yabs = myAbs(y);	// Absolute value of y to use for lookup table.
	float xabs = myAbs(x);	// Absolute value of x to use for lookup table.
	int index;				// Index of the degrees value from the lookup table.
	float retVal = 0.0;		// Return value of angle.

	// Tangent becomes very non-linear past 45 degrees. It is therefore best to only calculate inverse tangent in this range.
	// Depending on the sector y/x or x/y must be used to search the 0.0 to 45.0 degree lookup table.

	// If both y and x values are positive in first quadrant (0.0 to 90.0 degrees).
	if ((y >= 0) && (x >= 0)) {
		// In first sector (0.0 to 45.0 degrees);
		if (yabs <= xabs) {
			if (xabs == 0.0) { xabs = 0.00001; }	// avoid a divide by zero by adding a slight error.
			index = (int)((yabs / xabs + 0.0025) * 200.0);
			retVal = (lookup2[index][1]);
		}
		// In second sector (45.0 to 90.0 degrees);
		else {
			if (yabs == 0.0) { yabs = 0.00001; }	// avoid a divide by zero by adding a slight error.
			index = (int)((xabs / yabs + 0.0025) * 200.0);
			retVal = (90.0 - lookup2[index][1]);
		}
	}
	// If y is positive and x is negative in second quadrant (90.0 to 180.0 degrees).
	else if ((y >= 0) && (x < 0)) {
		if (yabs >= xabs) {
			if (yabs == 0.0) { yabs = 0.00001; }
			index = (int)((xabs / yabs + 0.0025) * 200.0);
			retVal = (90.0 + lookup2[index][1]);
		}
		else {
			if (xabs == 0.0) { xabs = 0.00001; }
			index = (int)((yabs / xabs + 0.0025) * 200.0);
			retVal = (180.0 - lookup2[index][1]);
		}
	}
	// If both y and x are negative in third quadrant (180.0 to 270.0 degrees).
	else if ((y < 0) && (x < 0)) {
		if (yabs <= xabs) {
			if (yabs == 0.0) { yabs = 0.00001; }
			index = (int)((yabs / xabs + 0.0025) * 200.0);
			retVal = (180.0 + lookup2[index][1]);
		}
		else {
			if (xabs == 0.0) { xabs = 0.00001; }
			index = (int)((xabs / yabs + 0.0025) * 200.0);
			retVal = (270.0 - lookup2[index][1]);
		}
	}
	// If y is negative and x is positive in fourth quadrant (270.0 to 360.0 degrees).
	else if ((y < 0) && (x >= 0)) {
		if (yabs >= xabs) {
			if (yabs == 0.0) { yabs = 0.00001; }
			index = (int)((xabs / yabs + 0.0025) * 200.0);
			retVal = (270.0 + lookup2[index][1]);
		}
		else {
			if (xabs == 0.0) { xabs = 0.00001; }
			index = (int)((yabs / xabs + 0.0025) * 200.0);
			retVal = (360.0 - lookup2[index][1]);
		}
	}
	return ((float)retVal);
}

// Replacement for sin function if maths library not available.
static float mySin(float angle) {
	int ang;

	// Can't do negative angles.
	if (angle < 0.0)
	{
		return -99.0;
	}

	// Calculate the index of the sine in the lookup table.
	ang = (int)((angle + 0.25) * 2.0);

	// Return the sine from the lookup table.
	// Ensure that angle is within the table by using remainder.
	return lookup1[ang % 720][1];
}

// Replacement for cos function if maths library not available.
static float myCos(float angle) {
	int ang;

	// Can't do negative angles.
	if (angle < 0.0)
	{
		return -99.0;
	}

	// Calculate the index of the cosine in the lookup table.
	ang = (int)((angle + 0.25) * 2.0);

	// Return the cosine from the lookup table.
	// Ensure that angle is within the table by using remainder.
	return lookup1[ang % 720][2];
}

// Replacement for sqrt function if maths library not available.
static float mySqrt(float square)
{
	float sqroot, column, work;
	int b;

	sqroot = 0.0;	// Set the square root to zero to support the search algorithm.

	// This function is limited to calculating the square root of a number less than 1 million.
	// The square root is calculated to 6 significant figures.
	// If the square passed in is less than 1, then the square root calculated will be less accurate.

	if (square >= 1000000) {
		return -1.0;
	}
	// Set the starting column depending on the magnitude of the square.
	else if (square > 10000) {
		column = 100.0;
	}
	else if (square > 100) {
		column = 10.0;
	}
	else {
		column = 1.0;
	}

	// The square root is calculated in decimal, because this is easy.
	// It would be more efficient to do this in binary.

	// Loop round 6 significant figures to calculate the square root.
	for (int a = 6; a > 0; a--) 
	{
		// Keep increasing the digit until the current square is greater than the square passed in to the function. 
		for (b = 1; b < 10; b++) 
		{
			work = column * (float)b;
			if (((sqroot + work) * (sqroot + work)) > square) 
			{
				break;
			}
		}
		// Use the digit before the one that used the total above the square. 
		// Add this to the working total and move down to the next decimal column.
		work = column * (float)(b - 1);
		sqroot = sqroot + work;
		column = column / 10.0;
	}
	// After calculating to 6 significant digits, return the value.
	return (sqroot);
}

// Draw a line of the colour specified.
// Taken from an internet example, but modified to allow line to go in any direction.
bool drawLine(float x1, float y1, float x2, float y2, unsigned int colour)
{
	float dx;	// difference on x axis
	float dy;	// difference on y axis
	float len;	// length of line
	float x;	// current x position
	float y;	// current y position.

	// Exit if the positions passed in are off the screen.
	if ((x1 >= 1240.0) || (y1 >= 720.0) || (x2 >= 1240.0) || (y2 >= 720.0))
	{
		return false;
	}
	if ((x1 < 0.0) || (y1 < 0.0) || (x2 < 0.0) || (y2 < 0.0))
	{
		return false;
	}

	// Calculate differences from start to end.
	dx = x2 - x1;
	dy = y2 - y1;

	// Set the length for the longer difference.
	if (myAbs(dx) >= myAbs(dy)) { len = myAbs(dx); }
	else { len = myAbs(dy); }

	// Divide by the length to give the step sizes for drawing. 
	dx = dx / len;
	dy = dy / len;

	// Set to the start of the line.
	x = x1;
	y = y1;

	// Count along the line length to draw the line.
	for (int i = 0; i <= len; i++)
	{
		OSScreenPutPixelEx(SCREEN_TV, x, y, colour);
		x = x + dx;
		y = y + dy;
	}
	return true;
}

// Draw an image on the screen at xpos and ypos.
bool drawImage(unsigned int xmax, unsigned int ymax, unsigned int ImageP[ymax][xmax], unsigned int xpos, unsigned int ypos)
{
	int xcntr, ycntr;	// Offsets to the centre of the image. Used to place the image centre on xpos and ypos.
	int xdisp, ydisp;	// Actual display pixels calculated.

	// For DonkeyKong-ish it is better to use the top left corner, rather than centre for positioning.
	xcntr = 0; // xmax / 2;	// X offset to centre of image
	ycntr = 0; // ymax / 2;	// Y offset to centre of image

	// Exit the function if the image size is not sensible.
	if ((xmax > XDISPMAX) || (ymax > YDISPMAX))
	{
		return false;
	}

	for (unsigned int y = 0; y < ymax; y++)
	{
		for (unsigned int x = 0; x < xmax; x++)
		{
			// Only display the pixel if it is not the background screen colour. This gives sprites a transparent background.
			// It also saves processing time.
			if (ImageP[y][x] != BKGNDCLR)
			{
				// Calculate the x pixel from the x position, x count adjusted for array start offset and centring.
				xdisp = xpos + x - xcntr;
				// Calculate the y pixel from the y position, y count adjusted for array start offset and centring.
				ydisp = ypos + ymax - y - 1 - ycntr;

				// Only display the pixel if it is inside the display screen.
				if ((xdisp < XDISPMAX) && (xdisp >= 0) && (ydisp < YDISPMAX) && (ydisp >= 0))
				{
					// The pixels in the bit map file start at the bottom but y=0 starts at the top of the screen.
					// The offsets are used to position the game screen within the TV screen.
					OSScreenPutPixelEx(SCREEN_TV, xdisp + XOFFSET, ydisp + YOFFSET, ImageP[y][x]);
				}
			}
		}
	}
	return true;
}

// Draw a line of the colour specified, used as part of displaying text.
// Taken from an internet example, but modified to allow line to go in any direction.
bool drawTextLine(float x1, float y1, float x2, float y2, unsigned int colour, unsigned int display)
{
	float dx;	// different on x axis
	float dy;	// difference on y axis
	float len;	// length of line
	float x;	// current x position
	float y;	// current y position.

	// Exit if the positions passed in are off the screen.
	if ((x1 >= 1240.0) || (y1 >= 720.0) || (x2 >= 1240.0) || (y2 >= 720.0))
	{
		return false;
	}
	if ((x1 < 0.0) || (y1 < 0.0) || (x2 < 0.0) || (y2 < 0.0))
	{
		return false;
	}

	// Calculate differences from start to end.
	dx = x2 - x1;
	dy = y2 - y1;

	// Set the length for the longer difference.
	if (myAbs(dx) >= myAbs(dy)) { len = myAbs(dx); }
	else { len = myAbs(dy); }

	// Divide by the length to give the step sizes for drawing. 
	dx = dx / len;
	dy = dy / len;

	// Set to the start of the line.
	x = x1;
	y = y1;

	// Count along the line length to draw the line.
	for (int i = 0; i <= len; i++)
	{
		OSScreenPutPixelEx(display, x, y, colour);
		x = x + dx;
		y = y + dy;
	}
	return true;
}

// Draw text at the position specified.
// In this case x and y position are not set to be within XDISPMAX and YDISPMAX, to allow text outside of the game play area.
bool drawText(char* dispString, unsigned int colour, unsigned int scale, unsigned int xpos, unsigned int ypos, unsigned int display)
{
	unsigned int mask;
	int b;
	char e;

	// Exit if the positions passed in, are off the screen.
	// Unsigned so can't go negative.
	if ((xpos >= 1240) || (ypos >= 720))
	{
		return false;
	}
	// Exit if text size not sensible.
	if ((scale < 1) || (scale > 6))
	{
		return false;
	}
	// Exit if screen selected does not exist.
	if ((display != SCREEN_TV) && (display != SCREEN_DRC))
	{
		return false;
	}

	// Go throught the characters limit at a sensible length.
	for (int a = 0; a < 100; a++) {
		// If end of string is detected then exit.
		if (dispString[a] == 0x00) {
			break;
		}
		// If the character is outside the visible character set, then display a hash symbol.
		if ((dispString[a] < 0x20) || (dispString[a] > 127)) {
			b = '#';
		}
		else {
			b = dispString[a];
		}
		// The first 32 characters are not visible.
		b = (char)(b - 32);
		// Count through the 8 bytes of data that set the 8x8 bit settings for the character.
		for (int y = 0; y < 8; y++) {
			// Extract the byte for the current 8 pixels.
			e = font8x8_basic[b][y];
			mask = 1;	// Set the mask to the start of the byte.
			// Count through the 8 pixels to display them.
			for (int z = 0; z < 8; z++) {
				// Loop round for the number of actual pixels, per character pixel.
				for (int w = 0; w < scale; w++) {
					// Draw the lines to make up the current pixel.
					// The drawLine function will deal with any lines that are off the edge of the screen.
					if ((e & mask) != 0) {										// xpos is the x position within the entire screen.
						drawTextLine((a * 8 * scale) + (z * scale) + xpos,		// 8 pixels across chracter, multiplied by scale which is number of actual pixels per character pixel.
							(y * scale) + ypos + w,								// w is to move down by the scale number of pixels per character pixel.
							(a * 8 * scale) + (z * scale) + xpos + (scale - 1),	// z is the pixel position across the current row.
							(y * scale) + ypos + w,								// ypos is the y position within the entire screen.
							colour,												// colour is the 24bit colour in Wii U format.
							display);											// Gamepad DRC or TV screen.
					}
				}
				mask = mask << 1; // Move the mask to the next pixel.
			}
		}
	}
	return true;
}

// Put the text where x and y are the centre of the line of text.
bool drawTextCentred(char* dispString, unsigned int colour, unsigned int scale, unsigned int xpos, unsigned int ypos, unsigned int display)
{
	unsigned int mask;				// Mask used for bit processing.
	unsigned int numChar = 0;		// Number of characters in the string to be printed.
	unsigned int xposNew, yposNew;	// x and y positions modified so that the centre of the text is on xpos and ypos.
	int b;							// working variables.
	char e;

	// Exit if the positions passed in, are off the screen.
	// Unsigned so can't go negative.
	if ((xpos >= 1240) || (ypos >= 720))
	{
		return false;
	}
	// Exit if text size not sensible.
	if ((scale < 1) || (scale > 6))
	{
		return false;
	}
	// Exit if screen selected does not exist.
	if ((display != SCREEN_TV) && (display != SCREEN_DRC))
	{
		return false;
	}

	// Find how long the string. Strlen not used to avoid any differences between Wii U and PC.
	for (int a = 0; a < 100; a++) {
		// If end of string is detected then exit.
		if (dispString[a] == 0x00) {
			numChar = a;
			break;
		}
	}
	// Do calculations to centre the text on the x and y positions within the game area of the screen.
	// The xpos is adjusted for the XOFFSET to the start of the game screen, then to half the length of the string multiplied by the scaled pixels per character. 
	xposNew = xpos + XOFFSET - ((numChar / 2) * 8 * scale);
	// The ypos is adjusted for the YOFFSET to the start of the game screen, then to half the scaled height of the text pixels.
	yposNew = ypos + YOFFSET - (4 * scale);

	// Go throught the characters limit at a sensible length.
	for (int a = 0; a < 100; a++) {
		// If end of string is detected then exit.
		if (dispString[a] == 0x00) {
			break;
		}
		// If the character is outside the visible character set, then display a hash symbol.
		if ((dispString[a] < 0x20) || (dispString[a] > 127)) {
			b = '#';
		}
		else {
			b = dispString[a];
		}
		// The first 32 characters are not visible.
		b = (char)(b - 32);
		// Count through the 8 bytes of data that set the 8x8 bit settings for the character.
		for (int y = 0; y < 8; y++) {
			// Extract the byte for the current 8 pixels.
			e = font8x8_basic[b][y];
			mask = 1;	// Set the mask to the start of the byte.
			// Count through the 8 pixels to display them.
			for (int z = 0; z < 8; z++) {
				// Loop round for the number of actual pixels, per character pixel.
				for (int w = 0; w < scale; w++) {
					// Draw the lines to make up the current pixel.
					// The drawLine function will deal with any lines that are off the edge of the screen.
					if ((e & mask) != 0) {											// xposNew is the x centred position within the game screen.
						drawTextLine((a * 8 * scale) + (z * scale) + xposNew,		// 8 pixels across chracter, multiplied by scale which is number of actual pixels per character pixel.
							(y * scale) + yposNew + w,								// w is to move down by the scale number of pixels per character pixel.
							(a * 8 * scale) + (z * scale) + xposNew + (scale - 1),	// z is the pixel position across the current row.
							(y * scale) + yposNew + w,								// ypos is the y centred position within the game screen.
							colour,													// colour is the 24bit colour in Wii U format.
							display);												// Gamepad DRC or TV screen.
					}
				}
				mask = mask << 1; // Move the mask to the next pixel.
			}
		}
	}
	return true;
}

// Initialise 3D array for rotating image.
bool initialiseRotatingImage(unsigned int xmax, unsigned int ymax, unsigned int ImageP[ymax][xmax], unsigned int ImagesP[ZMAX][ymax][xmax])
{
	float	xcntr, ycntr;	// Offsets to the centre of the image.
	float	xdisp, ydisp;	// Pixel displacement.
	float	pixAng, pixLen;	// Polar coordinates for pixel.
	float	xadd, yadd;		// Adjustmest to pixels for rotation.
	int		xnew, ynew;		// New pixel position.

	xcntr = xmax / 2;	// X offset to centre of image
	ycntr = ymax / 2;	// Y offset to centre of image

	// Fill everything with the background colour.
	for (unsigned int z = 0; z < ZMAX; z++)
	{
		for (unsigned int y = 0; y < ymax; y++)
		{
			for (unsigned int x = 0; x < xmax; x++)
			{
				ImagesP[z][y][x] = BKGNDCLR;
			}
		}
	}

	// Put the first image at the start of the array.
	for (unsigned int y = 0; y < ymax; y++)
	{
		for (unsigned int x = 0; x < xmax; x++)
		{
			ImagesP[0][y][x] = ImageP[y][x];
		}
	}

	// Fill the rest of the array with images rotated by 360 degrees / the number of images.
	for (unsigned int z = 1; z < ZMAX; z++)
	{
		for (unsigned int y = 0; y < ymax; y++)
		{
			for (unsigned int x = 0; x < xmax; x++)
			{
				xdisp = x - xcntr;										// Get the x and y values in relation to the centre of the image.
				ydisp = y - ycntr;
				pixAng = myAtan2(ydisp, xdisp);							// Get the angle of the pixel relating to the centre of the image.
				pixLen = mySqrt((xdisp * xdisp) + (ydisp * ydisp));		// Get the distance from the centre of the image.
				pixAng = pixAng + (360.0 / ZMAX * z);					// Add the rotation angle around the centre.
				xadd = myCos(pixAng) * pixLen;							// Convert the distance and angle back to X and Y coordinates.
				yadd = mySin(pixAng) * pixLen;							
				xadd = xadd + xcntr;									// Remove the offset for centre to get the actual pixel position in the array.
				yadd = yadd + ycntr;
				ynew = (int)(yadd + 0.5);								// Convert to integer pixel positions, ensuring correct rounding.
				xnew = (int)(xadd + 0.5);
				// Only put the pixel in, if it is inside the image.
				if ((ynew < ymax) && (ynew >= 0) && (xnew < xmax) && (xnew >= 0))
				{
					ImagesP[z][ynew][xnew] = ImageP[y][x];
				}
			}
		}

		// Rotating can leave gaps in the pixels. Find pixels that are the background colour, but that are surounded.
		// Change these to match adjacent pixels.
		for (unsigned int y = 1; y < ymax - 1; y++)
		{
			for (unsigned int x = 1; x < xmax - 1; x++)
			{
				if (ImagesP[z][y][x] == BKGNDCLR)
				{
					int pcnt = 0;
					if (ImagesP[z][y - 1][x] != BKGNDCLR) { pcnt++; }
					if (ImagesP[z][y + 1][x] != BKGNDCLR) { pcnt++; }
					if (ImagesP[z][y][x - 1] != BKGNDCLR) { pcnt++; }
					if (ImagesP[z][y][x + 1] != BKGNDCLR) { pcnt++; }

					// if a pixel is still set at the background colour check the colour of surrounding pixels.
					if (pcnt > 2)
					{
						if      (ImagesP[z][y - 1][x] != BKGNDCLR)	{ ImagesP[z][y][x] = ImagesP[z][y - 1][x]; }
						else if (ImagesP[z][y][x - 1] != BKGNDCLR)	{ ImagesP[z][y][x] = ImagesP[z][y][x - 1]; }
						else										{ ImagesP[z][y][x] = ImagesP[z][y][x + 1]; }
					}
				}
			}
		}

	}
	return true;
}

// Draw a rotated image on the screen at xpos and ypos.
bool rotateImage(unsigned int xmax, unsigned int ymax, unsigned int ImageP[ZMAX][ymax][xmax], unsigned int xpos, unsigned int ypos, unsigned int angle)
{
	int xcntr, ycntr;	// Offsets to the centre of the image. Used to place the image centre on xpos and ypos.
	int xdisp, ydisp;	// Actual display pixels calculated.
	int image;

	xcntr = xmax / 2;	// X offset to centre of image
	ycntr = ymax / 2;	// Y offset to centre of image

	// Exit the function if the image size is not sensible.
	if ((xmax > XDISPMAX) || (ymax > YDISPMAX))
	{
		return false;
	}

	// Determine the closest image. Add half the angle between images to the angle so that rounding acts correctly. 
	// Using % ZMAX will always limit the image chosen to within the array.
	image = 360 / ZMAX / 2;
	image = (int)((((float)angle + (float)image) / 360.0) * ZMAX) % ZMAX;

	for (unsigned int y = 0; y < ymax; y++)
	{
		for (unsigned int x = 0; x < xmax; x++)
		{
			// Only display the pixel if it is not the background screen colour. This gives sprites a transparent background.
			// It also saves processing time.
			if (ImageP[image][y][x] != BKGNDCLR)
			{
				// Calculate the x pixel from the x position, x count adjusted for array start offset and centring.
				xdisp = xpos + x - xcntr;
				// Calculate the y pixel from the y position, y count adjusted for array start offset and centring.
				ydisp = ypos + ymax - y - 1 - ycntr;

				// Only display the pixel if it is inside the display screen.
				if ((xdisp < XDISPMAX) && (xdisp >= 0) && (ydisp < YDISPMAX) && (ydisp >= 0))
				{
					// The pixels in the bit map file start at the bottom but y=0 starts at the top of the screen.
					// The offsets are used to position the game screen within the TV screen.
					OSScreenPutPixelEx(SCREEN_TV, xdisp + XOFFSET, ydisp + YOFFSET, ImageP[image][y][x]);
				}
			}
		}
	}
	return true;
}

// Draw the visible part of the background based on xpos and ypos.
// The background scrolls in the opposite direction of movement.
bool drawBackground(unsigned int xmax, unsigned int ymax, unsigned int ImageP[ymax][xmax], unsigned int xpos, unsigned int ypos)
{
	int xcntr, ycntr;	// Offsets to the centre of the image. Used to place the image centre on xpos and ypos.
	int xdisp, ydisp;	// Actual display pixels calculated.
	unsigned int xstrt, ystrt, xend, yend;	// Working start and end limits to display the visible part of the image.

	xcntr = xmax / 2;	// X offset to centre of image
	ycntr = ymax / 2;	// Y offset to centre of image

	// Exit the function if the image size is not sensible.
	if ((xmax > 1201) || (ymax > 901))
	{
		return false;
	}

	// If the image is larger than the display area. Only process the pixels in the display area to save time.
	if (xmax > XDISPMAX)
	{
		// Set the start and end to the data points that are within the area that will be displayed.
		// Avoid wating time processing data that is off the screen.
		xstrt = xmax - xcntr + xpos - XDISPMAX;
		xend = xmax - xcntr + xpos;
		// Ensure that we don't go off the end of the array.
		if (xstrt < 0)    { xstrt = 0; }
		if (xend  > xmax) { xend = xmax; }
	}
	else
	{
		xstrt = 0;
		// If the image is larger than the display limit to the display size.
		if (xmax < XDISPMAX) { xend = xmax; }
		else                 { xend = XDISPMAX; }
	}

	// If the image is larger than the display area. Only process the pixels in the display area to save time.
	if (ymax > YDISPMAX)
	{
		// Set the start and end to the data points that are within the area that will be displayed.
		// Avoid wating time processing data that is off the screen.
		ystrt = ymax - ycntr + ypos - YDISPMAX;
		yend = ymax - ycntr + ypos;
		// Ensure that we don't go off the end of the array.
		if (ystrt < 0)    { ystrt = 0; }
		if (yend  > ymax) { yend = ymax; }
	}
	else
	{
		ystrt = 0;
		// If the image is larger than the display limit to the display size.
		if (ymax < YDISPMAX) { yend = ymax; }
		else                 { yend = YDISPMAX; }
	}

	// Go through all of the visible pixels and set the screen to match the data.
	for (unsigned int y = ystrt; y < yend; y++)
	{
		for (unsigned int x = xstrt; x < xend; x++)
		{
			// Only display the pixel if it is not the background screen colour. This gives sprites a transparent background.
			// It also saves processing time.
			if (ImageP[y][x] != BKGNDCLR)
			{
				// Calculate the x pixel from the x position, x count adjusted for array start offset and centring.
				xdisp = x - xstrt;
				// Calculate the y pixel from the y position, y count adjusted for array start offset and centring.
				ydisp = YDISPMAX - (y - ystrt);

				// The pixels in the bit map file start at the bottom but y=0 starts at the top of the screen.
				// The offsets are used to position the game screen within the TV screen.
				OSScreenPutPixelEx(SCREEN_TV, xdisp + XOFFSET, ydisp + YOFFSET, ImageP[y][x]);
			}
		}
	}
	return true;
}

// Draw a scaled image on the screen at xpos and ypos. Scaled between 0% and 100%.
bool scaleImage(unsigned int xmax, unsigned int ymax, unsigned int ImageP[ymax][xmax], unsigned int xpos, unsigned int ypos, float pct)
{
	int xcntr, ycntr;	// Offsets to the centre of the image. Used to place the image centre on xpos and ypos.
	int xdisp, ydisp;	// Actual display pixels calculated.
	int xend, yend;		// end of image scaled down from xmax and ymax.
	float scale;		// scaling (1 over percent size).

	// Limit display to the maximum image size.
	if (pct > 100.0)
	{
		pct = 100.0;
	}

	// Exit the function if the image size is not sensible.
	if ((xmax > XDISPMAX) || (ymax > YDISPMAX))
	{
		return false;
	}

	xcntr = xmax / 2;	// X offset to centre of image
	ycntr = ymax / 2;	// Y offset to centre of image

	// Resize image to percentage, but limit to maximum size of the image array.
	xend = (int)((float)(xmax) * pct / 100.0);
	if (xend > xmax) { xend = xmax; }
	yend = (int)((float)(ymax) * pct / 100.0);
	if (yend > ymax) { yend = ymax; }

	// scale is used to process data points within the image.
	scale = 1.0 / (pct / 100.0);

	// Go through all displayed data points.
	for (unsigned int y = 0; y < yend; y++)
	{
		for (unsigned int x = 0; x < xend; x++)
		{
			// Only display the pixel if it is not the background screen colour. This gives sprites a transparent background.
			// It also saves some processing time.
			if (ImageP[(int)(y * scale)][(int)(x * scale)] != BKGNDCLR)
			{
				// Calculate the x pixel from the x position, x count adjusted for array start offset and centring.
				xdisp = xpos + x - (int)((float)xcntr * pct / 100.0);
				// Calculate the y pixel from the y position, y count adjusted for array start offset and centring.
				ydisp = ypos + yend - y - 1 - (int)((float)ycntr * pct / 100.0);

				// Only display the pixel if it is inside the display screen.
				if ((xdisp < XDISPMAX) && (xdisp >= 0) && (ydisp < YDISPMAX) && (ydisp >= 0))
				{
					// The pixels in the bit map file start at the bottom but y=0 starts at the top of the screen.
					// The offsets are used to position the game screen within the TV screen.
					// Scaling is used to linearly interpolate the image to a smaller size.
					OSScreenPutPixelEx(SCREEN_TV, xdisp + XOFFSET, ydisp + YOFFSET, ImageP[(int)(y * scale)][(int)(x * scale)]);
				}
			}
		}
	}
	return true;
}

